import os
import random
import time
import signal
import ssl
import paho.mqtt.client as mqtt

BROKER_HOST = os.getenv("BROKER_HOST", "mqtt-broker")
BROKER_PORT = int(os.getenv("BROKER_PORT", "8883"))  # porta TLS padrão
TOPIC       = os.getenv("TOPIC", "sensor/temperature")

INTERVAL = float(os.getenv("INTERVAL_SECONDS", "5"))
if INTERVAL < 1.0:
    raise ValueError("INTERVAL_SECONDS deve ser >= 1")

QOS = int(os.getenv("QOS", "0"))
if QOS not in (0, 1, 2):
    raise ValueError("QOS inválido, use 0, 1 ou 2")

RETAIN = os.getenv("RETAIN", "false").lower() == "true"


USERNAME = os.getenv("MQTT_USER")
PASSWORD = os.getenv("MQTT_PASS")
if not USERNAME or not PASSWORD:
    raise EnvironmentError("Defina MQTT_USER e MQTT_PASS")

CA_CERT = os.getenv("CA_CERT", "/etc/mqtt/ca.crt")
if not os.path.exists(CA_CERT):
    raise FileNotFoundError(f"Certificado CA não encontrado: {CA_CERT}")

def generate_temperature():
    value = getattr(generate_temperature, "_val", 22.0)
    step = random.uniform(-0.5, 0.7)
    value = max(-40.0, min(140.0, value + step))
    generate_temperature._val = value
    return round(value, 2)

def on_connect(client, userdata, flags, rc, properties=None):
    print(f"[sensor] Connected to {BROKER_HOST}:{BROKER_PORT} rc={rc}", flush=True)

def on_disconnect(client, userdata, rc, properties=None):
    print(f"[sensor] Disconnected rc={rc}", flush=True)

def main():
    client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect

    client.username_pw_set(USERNAME, PASSWORD)

    client.tls_set(ca_certs=CA_CERT, tls_version=ssl.PROTOCOL_TLSv1_2)
    client.tls_insecure_set(False)

    client.reconnect_delay_set(min_delay=1, max_delay=30)
    client.connect(BROKER_HOST, BROKER_PORT, keepalive=30)
    client.loop_start()

    stop = False
    def handle_sig(signum, frame):
        nonlocal stop
        stop = True
        print("[sensor] Stopping...", flush=True)
    signal.signal(signal.SIGTERM, handle_sig)
    signal.signal(signal.SIGINT, handle_sig)

    while not stop:
        temp = generate_temperature()
        payload = str(temp)
        info = client.publish(TOPIC, payload, qos=QOS, retain=RETAIN)
        info.wait_for_publish()
        print(f"[sensor] Published {payload} to '{TOPIC}' (qos={QOS}, retain={RETAIN})", flush=True)
        time.sleep(INTERVAL)

    client.loop_stop()
    client.disconnect()

if __name__ == "__main__":
    main()
